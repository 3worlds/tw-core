tree

hasNode dynamicsSpec
	isOfClass = String("dynamics")
	hasParent =  au.edu.anu.rscs.aot.collections.tables.StringTable(([1]"system:"))
	multiplicity = IntegerRange("1..1")

// this to be removed soon - cf function specs below
//hasNode initialisationSpec
//	isOfClass = String("initialiser")
//	hasParent = StringTable(([1]"dynamics:"))
//	multiplicity = IntegerRange("0..1")
//	mustSatisfyQuery initialiserNameWithUppercaseQuery
//		className = String("au.edu.anu.twcore.archetype.tw.NameStartsWithUpperCaseQuery")
//	hasEdge initAppliesToCategorySpec
//		isOfClass = String("appliesTo")
//		toNode = String("category:")
//		multiplicity = IntegerRange("1..*")
//	hasProperty userInitialiserSpec
//		hasName = String("userClassName")
//		type = String("String")
//		multiplicity = IntegerRange("0..1")

hasNode timeLineSpec
	isOfClass = String("timeline")
	hasParent = StringTable(([1]"dynamics:"))
	multiplicity = IntegerRange("1..1")
	hasProperty scalePropertySpec
		hasName = String("scale")
		type =  String("TimeScaleType")
		multiplicity = IntegerRange("1..1")
	hasProperty shortestTimeUnitPropertySpec
		hasName = String("shortestTimeUnit")
		type =  String("TimeUnits")
		multiplicity = IntegerRange("1..1")
	hasProperty longestTimeUnitPropertySpec
		hasName = String("longestTimeUnit")
		type =  String("TimeUnits")
		multiplicity = IntegerRange("1..1")
	hasProperty timeOriginPropertySpec
		hasName = String("timeOrigin")
		type = String("DateTimeType")
		multiplicity = IntegerRange("1..1")
	mustSatisfyQuery shortestTimeUnitTimeUnitValidityQuery
		className = String("au.edu.anu.twcore.archetype.tw.TimeUnitValidityQuery")
		values = StringTable(([2]"shortestTimeUnit","scale"))
	mustSatisfyQuery longestTimeUnitTimeUnitValidityQuery
		className = String("au.edu.anu.twcore.archetype.tw.TimeUnitValidityQuery")
		values = StringTable(([2]"longestTimeUnit","scale"))
	mustSatisfyQuery TimeIntervalValidityQuery
		className = String("au.edu.anu.twcore.archetype.tw.TimeIntervalValidityQuery")
		values = StringTable(([3]shortestTimeUnit,"longestTimeUnit","scale"))

hasNode timeModelSpec
	isOfClass = String("timer")
	hasParent = StringTable(([1]"timeline:"))
	multiplicity = IntegerRange("1..*")
//	hasProperty timeUnitPropertySpec
//		hasName = String("timeUnit")
//		type =  String("TimeUnits")
//		multiplicity = IntegerRange("1..1")
//	mustSatisfyQuery timeUnitTimeUnitValidityQuery
//		className = String("au.edu.anu.twcore.archetype.tw.TimeUnitValidityQuery")
//		values = StringTable(([2]"timeUnit","scale"))
//	hasProperty
//		hasName = String("nTimeUnits")
//		type = String("Integer")
//		multiplicity = IntegerRange("1..1")
//		mustSatisfyQuery nTimeUnitsIsInRangeQuery
//			className = String("au.edu.anu.twcore.archetype.tw.IsInRangeQuery")
//			interval = IntTable(([2]1,2147483647))      // Integer.MAX_VALUE = 2^31-1 = 2147483647
	hasProperty timeModelSubclassPropertySpec
		hasName = String("subclass")
		type = String("String")
		multiplicity = IntegerRange("1..1")
		mustSatisfyQuery validTimeModelSubclassSpec
			className = String("au.edu.anu.twcore.archetype.tw.IsInValueSetQuery")
			values = StringTable(([3]+
			"au.edu.anu.twcore.ecosystem.runtime.timer.ClockTimer",+
			"au.edu.anu.twcore.ecosystem.runtime.timer.EventTimer",+
			"au.edu.anu.twcore.ecosystem.runtime.timer.ScenarioTimer"))
	mustSatisfyQuery CheckSubArchetypeQueryClockTimeModel
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.timer.ClockTimer","3wSA-ClockTimer.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryEventTimeModel
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.timer.EventTimer","3wSA-EventTimer.ugt"))

hasNode processSpec
	isOfClass = String("process")
	hasParent = StringTable(([1]"timer:"))
	multiplicity = IntegerRange("1..*")
	mustSatisfyQuery processHasFunctionOrDataTrackerChildQuery
		className = String("au.edu.anu.twcore.archetype.tw.NodeAtLeastOneChildLabelOfQuery")
		labels = StringTable(([2]"function","dataTracker"))
	hasEdge appliesToCategorySpec
		isOfClass = String("appliesTo")
		toNode = String("category:")
		multiplicity = IntegerRange("0..*")
	hasEdge appliesToRelationSpec
		isOfClass = String("appliesTo")
		toNode = String("relationType:")
		multiplicity = IntegerRange("0..1")
	mustSatisfyQuery processToRelationOrCategorySpec
		className = String("au.edu.anu.twcore.archetype.tw.OutNodeXorQuery")
		nodeLabel1 = String("category")
		nodeLabel2 = String("relationType")
	hasEdge dependsOnSpec
		isOfClass = String("dependsOn")
		toNode = String("process:")
		multiplicity = IntegerRange("0..*")
	hasEdge spaceEdgeSpec
		isOfClass = String("inSpace")
		toNode = String("space:")
		multiplicity = IntegerRange("0..1")
		hasProperty spaceMaxSearchRadiusSpec
			hasName = String("searchRadius")
			type = String("Double")
			multiplicity = IntegerRange("1..1")
			mustSatisfyQuery searchRadiusMustBeNonNullConstraint
				className = String("au.edu.anu.twcore.archetype.tw.IsInIntervalQuery")
				range = Interval(]0.0,+Inf[)

hasNode functionSpec
	isOfClass = String("function")
	hasParent = StringTable(([1]"process:"))
	multiplicity = IntegerRange("0..*")
	mustSatisfyQuery functionNameWithUppercaseQuery
		className = String("au.edu.anu.twcore.archetype.tw.NameStartsWithUpperCaseQuery")
	mustSatisfyQuery functionMatchesWithProcessTypeSpec
		className = String("au.edu.anu.twcore.archetype.tw.FunctionMatchProcessTypeQuery")
	hasProperty functionTypeSpec
		hasName = String("type")
		type = String("TwFunctionTypes")
		multiplicity = IntegerRange("1..1")
	hasProperty userFunctionSpec
		hasName = String("userClassName")
		type = String("String")
		multiplicity = IntegerRange("0..1")
	// a function may have a node to a RNG. if none is required, default is used
	// if more than one is needed, then make two functions.
	hasEdge functionRngSpec
		isOfClass = String("useRNG")
		toNode = String("rng:")
		multiplicity = IntegerRange("0..1")
	//------- specific to createOtherDecision
	// do we want to keep a parent link between offspring and parent?
	hasProperty relateToFunctionKeepLinkPropertySpec
		hasName = String("relateToProduct")
		type = String("Boolean")
		multiplicity = IntegerRange("0..1")
	mustSatisfyQuery FunctionTypePropertySpecQuery
		className = String("au.edu.anu.twcore.archetype.tw.RequirePropertyQuery")
		conditions = StringTable(([3]"relateToProduct","type","CreateOtherDecision"))
	//------- specific to relateToDecision
	// for relateToDecision function: must be the only one type of function in its process
	mustSatisfyQuery FunctionTypeExclusiveChildPropertyValueQueryQuery
		className = String("au.edu.anu.twcore.archetype.tw.ExclusiveChildPropertyValueQuery")
		propertyName = String("type")
		propertyValues = StringTable(([1]"RelateToDecision"))

hasNode consequenceFunctionSpec
	isOfClass = String("function")
	hasParent = StringTable(([1]"process:/function:"))
	// recursive - consequence of consequence of ...
	//hasParent = StringTable(([1]"function:"))
	multiplicity = IntegerRange("0..*")
	mustSatisfyQuery functionNameWithUppercaseQuery2
		className = String("au.edu.anu.twcore.archetype.tw.NameStartsWithUpperCaseQuery")
	mustSatisfyQuery functionMatchesWithParentFunctionTypeSpec
		className = String("au.edu.anu.twcore.archetype.tw.ConsequenceMatchFunctionTypeQuery")
	hasProperty csqfunctionTypeSpec
		// NB: default is ChangeState
		hasName = String("type")
		type = String("TwFunctionTypes")
		multiplicity = IntegerRange("1..1")
	hasProperty csquserFunctionSpec
		hasName = String("userClassName")
		type = String("String")
		multiplicity = IntegerRange("0..1")
	// a function may have a node to a RNG. if more than one is required, default is used
	// if more than one is needed, then make two functions.
	hasEdge csqfunctionRngSpec
		isOfClass = String("useRNG")
		toNode = String("rng:")
		multiplicity = IntegerRange("0..1")
	mustSatisfyQuery FunctionConsequenceTypePropertySpecQuery
		className = String("au.edu.anu.twcore.archetype.tw.RequirePropertyQuery")
		conditions = StringTable(([3]"relateToProduct","type","CreateOtherDecision"))
	// TODO: specific to 	ChangeOtherStateFunction when consequence of DeleteDecision:
	// must specify to which other item data should be returned...

hasNode snippet
	isOfClass = String("snippet")
	hasParent = StringTable(([3]"function:","initFunction:","process:/function:"))
	multiplicity = IntegerRange("0..*")
	hasProperty snippetProp
		hasName = String("javaCode")
		type = String("StringTable")
		multiplicity = IntegerRange("1..1")
	
hasNode dataTrackerSpec
	isOfClass = String("dataTracker")
	hasParent = StringTable(([1]"process:"))
	multiplicity = IntegerRange("0..*")
	hasProperty dataTrackerSubclassSpec
		hasName = String("subclass")
		type = String("String")
		multiplicity = IntegerRange("1..1")
		mustSatisfyQuery validDataTrackerSubClassSpec
			className = String("au.edu.anu.twcore.archetype.tw.IsInValueSetQuery")
			values = StringTable(([3]+
			"au.edu.anu.twcore.ecosystem.runtime.tracking.DataTracker0D",+
			"au.edu.anu.twcore.ecosystem.runtime.tracking.DataTrackerXY",+
			"au.edu.anu.twcore.ecosystem.runtime.tracking.DataTracker2D"))
	hasProperty SatisticsSpec
		hasName = String("statistics")
		type = String("StatisticalAggregatesSet")
		multiplicity = IntegerRange("0..1")
	hasProperty tableSatisticsSpec
		hasName = String("tableStatistics")
		type = String("StatisticalAggregatesSet")
		multiplicity = IntegerRange("0..1")
	// these two properties are only needed if there is a trackComponent edge
	hasProperty samplingModeSpec
		hasName = String("samplingMode")
		type = String("SamplingMode")
		multiplicity = IntegerRange("0..1") // if absent, only tracks the target component
	hasProperty sampleSizeSpec
		hasName = String("sampleSize")
		type = String("String") // valid values: any >0 number, or "ALL" - defaults to 1
		multiplicity = IntegerRange("0..1") // if absent, defaults to 1

	// tracking of data fields
	hasEdge trackFieldEdgeSpec
		isOfClass = String("trackField")
		toNode = String("field:")
		multiplicity = IntegerRange("0..*")
		mustSatisfyQuery validTrackFieldCategory
			className = String("au.edu.anu.twcore.archetype.tw.FindCommonCategoryQuery")
		// this may be needed if upper containers for the field are tables
		hasProperty trackTableIndexSpec
			hasName = String("index")
			type = String("TrackerType")
			multiplicity = IntegerRange("0..1")
		mustSatisfyQuery indexInTableDimRangeFieldSpec
			className = String("au.edu.anu.twcore.archetype.tw.IndexDimensionQuery")

	// tracking of table data
	hasEdge trackTableEdgeSpec
		isOfClass = String("trackTable")
		toNode = String("table:")
		multiplicity = IntegerRange("0..*")
		mustSatisfyQuery validTrackTableCategory
			className = String("au.edu.anu.twcore.archetype.tw.FindCommonCategoryQuery")
		mustSatisfyQuery leafTableSpec
			className = String("au.edu.anu.twcore.archetype.tw.EndNodeHasPropertyQuery")
			propname = String("dataElementType")
		hasProperty trackTableIndexSpec2
			hasName = String("index")
			type = String("TrackerType")
			multiplicity = IntegerRange("1..1")
		mustSatisfyQuery indexInTableDimRangeTableSpec
			className = String("au.edu.anu.twcore.archetype.tw.IndexDimensionQuery")

	// tracking of components (use with trackField and trackTable)
	hasEdge trackComponentEdgeSpec // track an initial list of components
		// todo: check this component is of the proper category?
		// also check all components are under the same group
		isOfClass = String("trackComponent")
		toNode = String("component:")
		multiplicity = IntegerRange("0..*")
	hasEdge trackComponentGroupEdgeSpec // track any components from this group
		// todo: check this group is of the proper category?
		isOfClass = String("trackComponent")
		toNode = String("group:")
		multiplicity = IntegerRange("0..1")
	hasEdge trackComponentEcosystemEdgeSpec // track any components at the ecosystem level
		// todo: check this component is of the proper category?
		isOfClass = String("trackComponent")
		toNode = String("system:") // was: initialState
		multiplicity = IntegerRange("0..1")

	// tracking of population data, ie groups
	hasEdge trackPopulationEdgeSpec
		// todo: check this population is of the proper category?
		isOfClass = String("trackPopulation")
		toNode = String("group:")
		multiplicity = IntegerRange("0..*")
		hasProperty trackPopulationVariableSpec
			hasName = String("variables")
			type = String("PopulationVariablesSet")
			multiplicity = IntegerRange("1..1")
	hasEdge trackTotalPopulationEdgeSpec
		isOfClass = String("trackPopulation")
		toNode = String("initialState:")
		multiplicity = IntegerRange("0..*")
		hasProperty trackTotalPopulationVariableSpec
			hasName = String("variables")
			type = String("PopulationVariablesSet")
			multiplicity = IntegerRange("1..1")
	mustSatisfyQuery trackItemConditionSpec
		className = String("au.edu.anu.twcore.archetype.tw.OutEdgeXorQuery")
		edgeLabel1 = String("trackPopulation")
		edgeLabel2 = StringTable(([3]"trackField","trackTable","trackComponent"))
	mustSatisfyQuery ifComponentMustHaveEitherFieldOrTableEdge
		className = String("au.edu.anu.twcore.archetype.tw.OutEdgeXNorQuery")
		edgeLabel1 = String("trackComponent")
		edgeLabel2 = StringTable(([2]"trackField","trackTable"))

hasNode lifeCycleSpec
	isOfClass = String("lifeCycle")
	hasParent = StringTable(([1]"dynamics:"))
	multiplicity = IntegerRange("0..*")
	hasProperty lifeCycleParameterSpec
		hasName = String("parameterClass")
		type =  String("String")
		multiplicity = IntegerRange("0..1")
	hasEdge lifeCycleToCategorySetSpec
		isOfClass = String("appliesTo")
		toNode = String("categorySet:")
		multiplicity = IntegerRange("1..1")
	mustSatisfyQuery lifeCycleHasRecruitOrProduceChildQuery
		className = String("au.edu.anu.twcore.archetype.tw.NodeAtLeastOneChildLabelOfQuery")
		labels = StringTable(([2]"recruit","produce"))
	// TODO: check this category is not used by Systems, ie lifeCycle categories and system
	// categories should be completely separate
	hasEdge lifeCycleCategoryBelongsToSpec
		isOfClass = String("belongsTo")
		toNode = String("category:")
		multiplicity = IntegerRange("0..*")

hasNode recruitSpec
	isOfClass = String("recruit")
	hasParent = StringTable(([1]"lifeCycle:"))
	multiplicity = IntegerRange("0..*")
	hasEdge recruitProcessSpec
		isOfClass = String("effectedBy")
		toNode = String("process:")
		multiplicity = IntegerRange("1..1")
	hasEdge recruitToCategorySpec
		isOfClass = String("toCategory")
		toNode = String("category:")
		multiplicity = IntegerRange("1..1")
	hasEdge recruitFromCategorySpec
		isOfClass = String("fromCategory")
		toNode = String("category:")
		multiplicity = IntegerRange("1..1")
	mustSatisfyQuery recruitCategoryInLifeCycleSet
		className = String("au.edu.anu.twcore.archetype.tw.IsInLifeCycleCategorySetQuery")
	mustSatisfyQuery validRecruitProcess
		className = String("au.edu.anu.twcore.archetype.tw.ValidLifeCycleProcessQuery")

hasNode produceSpec
	isOfClass = String("produce")
	hasParent = StringTable(([1]"lifeCycle:"))
	multiplicity = IntegerRange("0..*")
	hasEdge productionProcessSpec
		isOfClass = String("effectedBy")
		toNode = String("process:")
		multiplicity = IntegerRange("1..1")
	hasEdge produceToCategorySpec
		isOfClass = String("toCategory")
		toNode = String("category:")
		multiplicity = IntegerRange("1..1")
	hasEdge produceFromCategorySpec
		isOfClass = String("fromCategory")
		toNode = String("category:")
		multiplicity = IntegerRange("1..1")
	mustSatisfyQuery produceCategoryInLifeCycleSet
		className = String("au.edu.anu.twcore.archetype.tw.IsInLifeCycleCategorySetQuery")
	mustSatisfyQuery validProduceProcess
		className = String("au.edu.anu.twcore.archetype.tw.ValidLifeCycleProcessQuery")

hasNode stoppingConditionSpec
	isOfClass = String("stoppingCondition")
	hasParent = StringTable(([1]"dynamics:"))
	// I think we should enforce at least one rather than have a default one if omitted
	// No - the default is: run forever. Means no stopping condition
	multiplicity = IntegerRange("0..*")
	hasProperty stoppingConditionSubclassPropertySpec
		hasName = String("subclass")
		type = String("String")
		multiplicity = IntegerRange("1..1")
		mustSatisfyQuery validStoppingConditionSubClassSpec
			className = String("au.edu.anu.twcore.archetype.tw.IsInValueSetQuery")
			values = StringTable(([6]+
			"au.edu.anu.twcore.ecosystem.runtime.stop.SimpleStoppingCondition",+
			"au.edu.anu.twcore.ecosystem.runtime.stop.ValueStoppingCondition",+
			"au.edu.anu.twcore.ecosystem.runtime.stop.InRangeStoppingCondition",+
			"au.edu.anu.twcore.ecosystem.runtime.stop.OutRangeStoppingCondition",+
			"au.edu.anu.twcore.ecosystem.runtime.stop.MultipleOrStoppingCondition",+
			"au.edu.anu.twcore.ecosystem.runtime.stop.MultipleAndStoppingCondition"))
	mustSatisfyQuery CheckSubArchetypeQuerySimpleStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.SimpleStoppingCondition","3wSA-SimpleStoppingCondition.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryValueStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.ValueStoppingCondition","3wSA-ValueStoppingCondition.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryInRangeStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.InRangeStoppingCondition","3wSA-RangeStoppingCondition.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryOutRangeStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.OutRangeStoppingCondition","3wSA-RangeStoppingCondition.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryMultipleOrStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.MultipleOrStoppingCondition","3wSA-MultipleStoppingCondition.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryMultipleAndStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.MultipleAndStoppingCondition","3wSA-MultipleStoppingCondition.ugt"))

// how to specify initial community:

//hasNode initialStateSpec
//	isOfClass = String("initialState")
//	hasParent = StringTable(([1]"dynamics:"))
//	multiplicity = IntegerRange("0..1")
//	hasEdge ecosystemToSourceLoadFromSpec
//		isOfClass = String("loadFrom")
//		toNode = String("dataSource:")
//		multiplicity = IntegerRange("0..*")


//	// initial state for an individual component// now moved to child of ComponentType in Structure

//	hasNode componentSpec
//		isOfClass = String("component")
//		hasParent = StringTable(([2]"initialState:","group:"))
//		multiplicity = IntegerRange("0..*")
//		hasEdge componentToSystemSpec
//			isOfClass = String("instanceOf")
//			toNode = String("componentType:")
//			multiplicity = IntegerRange("1..1")
//		hasEdge componentToSpaceSpec
//			isOfClass = String("location")
//			toNode = String("space:")
//			multiplicity = IntegerRange("0..1")
//			hasProperty spaceComponentCoordinatesSpec
//				hasName = String("coordinates")
//				type = String("DoubleTable")
//				multiplicity = IntegerRange("1..1")
////		mustSatisfyQuery mustHaveCoordinatesSpec
////			className = String("au.edu.anu.twcore.archetype.tw.RequiresCoordinatesQuery")
//		hasEdge instanceOfToSourceLoadFromSpec
//			isOfClass = String("loadFrom")
//			toNode = String("dataSource:")
//			multiplicity = IntegerRange("0..*")

