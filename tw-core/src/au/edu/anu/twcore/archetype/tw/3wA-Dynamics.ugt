tree

hasNode dynamicsSpec
	isOfClass = String("dynamics")
	hasParent =  au.edu.anu.rscs.aot.collections.tables.StringTable(([1]"system:"))
	multiplicity = IntegerRange("1..1")

hasNode initialisationSpec
	isOfClass = String("initialiser")
	hasParent = StringTable(([1]"dynamics:"))
	multiplicity = IntegerRange("0..1")
	mustSatisfyQuery initialiserNameWithUppercaseQuery
		className = String("au.edu.anu.twcore.archetype.tw.NameStartsWithUpperCaseQuery")
	
hasNode timeLineSpec
	isOfClass = String("timeLine")
	hasParent = StringTable(([1]"dynamics:"))
	multiplicity = IntegerRange("1..1")
	hasProperty scalePropertySpec
		hasName = String("scale")
		type =  String("TimeScaleType") 
		multiplicity = IntegerRange("1..1") 
	hasProperty shortestTimeUnitPropertySpec
		hasName = String("shortestTimeUnit")
		type =  String("TimeUnits") 
		multiplicity = IntegerRange("1..1") 
	hasProperty longestTimeUnitPropertySpec
		hasName = String("longestTimeUnit")
		type =  String("TimeUnits") 
		multiplicity = IntegerRange("1..1") 
	hasProperty timeOriginPropertySpec
		hasName = String("timeOrigin")
		type = String("DateTimeType")
		multiplicity = IntegerRange("1..1") 
	mustSatisfyQuery shortestTimeUnitTimeUnitValidityQuery
		className = String("au.edu.anu.twcore.archetype.tw.TimeUnitValidityQuery")
		values = StringTable(([2]"shortestTimeUnit","scale"))
	mustSatisfyQuery longestTimeUnitTimeUnitValidityQuery
		className = String("au.edu.anu.twcore.archetype.tw.TimeUnitValidityQuery")
		values = StringTable(([2]"longestTimeUnit","scale"))
	mustSatisfyQuery TimeIntervalValidityQuery
		className = String("au.edu.anu.twcore.archetype.tw.TimeIntervalValidityQuery")
		values = StringTable(([3]shortestTimeUnit,"longestTimeUnit","scale"))

hasNode timeModelSpec
	isOfClass = String("timeModel")
	hasParent = StringTable(([1]"timeLine:"))
	multiplicity = IntegerRange("1..*")
	hasProperty timeUnitPropertySpec
		hasName = String("timeUnit")
		type =  String("TimeUnits")
		multiplicity = IntegerRange("1..1")
	mustSatisfyQuery timeUnitTimeUnitValidityQuery
		className = String("au.edu.anu.twcore.archetype.tw.TimeUnitValidityQuery")
		values = StringTable(([2]"timeUnit","scale"))
	hasProperty 
		hasName = String("nTimeUnits")
		type = String("Integer")
		multiplicity = IntegerRange("1..1")
		mustSatisfyQuery nTimeUnitsIsInRangeQuery
			className = String("au.edu.anu.twcore.archetype.tw.IsInRangeQuery")
			interval = IntTable(([2]1,2147483647))      // Integer.MAX_VALUE = 2^31-1 = 2147483647
	hasProperty timeModelSubclassPropertySpec
		hasName = String("subclass")
		type = String("String")
		multiplicity = IntegerRange("1..1")
		mustSatisfyQuery validTimeModelSubclassSpec
			className = String("au.edu.anu.twcore.archetype.tw.IsInValueSetQuery")
			values = StringTable(([3]+
			"au.edu.anu.twcore.ecosystem.runtime.timer.ClockTimer",+
			"au.edu.anu.twcore.ecosystem.runtime.timer.EventTimer",+
			"au.edu.anu.twcore.ecosystem.runtime.timer.ScenarioTimer"))
	mustSatisfyQuery CheckSubArchetypeQueryClockTimeModel
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.timer.ClockTimer","3wSA-ClockTimer.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryEventTimeModel
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.timer.EventTimer","3wSA-EventTimer.ugt"))

hasNode processSpec
	isOfClass = String("process")
	hasParent = StringTable(([1]"timeModel:"))
	multiplicity = IntegerRange("1..*")
	mustSatisfyQuery processHasFunctionOrDataTrackerChildQuery
		className = String("au.edu.anu.twcore.archetype.tw.NodeAtLeastOneChildLabelOfQuery")
		labels = StringTable(([2]"function","dataTracker"))
	hasEdge appliesToCategorySpec
		isOfClass = String("appliesTo")
		toNode = String("category")
		multiplicity = IntegerRange("0..*")
	hasEdge appliesToRelationSpec
		isOfClass = String("appliesTo")
		toNode = String("relationType")
		multiplicity = IntegerRange("0..1")
	mustSatisfyQuery processToRelationOrCategorySpec
		className = String("au.edu.anu.twcore.archetype.tw.OutNodeXorQuery")
		nodeLabel1 = String("category")
		nodeLabel2 = String("relationType")
	hasEdge dependsOnSpec
		isOfClass = String("dependsOn")
		toNode = String("process")
		multiplicity = IntegerRange("0..*")

hasNode functionSpec
	isOfClass = String("function")
	hasParent = StringTable(([2]"process:","process:/function:"))
	multiplicity = IntegerRange("0..*")
	mustSatisfyQuery functionNameWithUppercaseQuery
		className = String("au.edu.anu.twcore.archetype.tw.NameStartsWithUpperCaseQuery")
	mustSatisfyQuery functionMatchesWithProcessTypeSpec
		className = String("au.edu.anu.twcore.archetype.tw.FunctionMatchProcessTypeQuery")
	hasProperty functionTypeSpec
		hasName = String("type")
		type = String("TwFunctionTypes")
		multiplicity = IntegerRange("1..1")
	hasProperty userFunctionSpec
		hasName = String("userClassName")
		type = String("String")
		multiplicity = IntegerRange("0..1")
		
hasNode dataTrackerSpec
	isOfClass = String("dataTracker")
	hasParent = StringTable(([1]"process:"))
	multiplicity = IntegerRange("0..*")
	hasProperty dataTrackerSubclassSpec
		hasName = String("subclass")
		type = String("String")
		multiplicity = IntegerRange("1..1")
		mustSatisfyQuery validDataTrackerSubClassSpec
			className = String("au.edu.anu.twcore.archetype.tw.IsInValueSetQuery")
			values = StringTable(([3]+
			"au.edu.anu.twcore.ecosystem.runtime.tracking.TimeSeriesTracker",+
			"au.edu.anu.twcore.ecosystem.runtime.tracking.MapTracker",+
			"au.edu.anu.twcore.ecosystem.runtime.tracking.LabelValuePairTracker"))
	hasProperty selectSpec
		hasName = String("select")
		type = String("SamplingMode") 
		multiplicity = IntegerRange("0..1")
	hasProperty SatisticsSpec
		hasName = String("statistics")
		type = String("StatisticalAggregatesSet")
		multiplicity = IntegerRange("0..1") 
	hasProperty tableSatisticsSpec
		hasName = String("tableStatistics")
		type = String("StatisticalAggregatesSet")
		multiplicity = IntegerRange("0..1") 
	hasEdge trackFieldEdgeSpec
		isOfClass = String("trackField")
		toNode = String("field")
		multiplicity = IntegerRange("0..*")
		mustSatisfyQuery validTrackFieldCategory
			className = String("au.edu.anu.twcore.archetype.tw.FindCommonCategoryQuery")
		// this may be needed if upper containers for the field are tables
		hasProperty trackTableIndexSpec
			hasName = String("index")
			type = String("TrackerType")
			multiplicity = IntegerRange("0..1")
		mustSatisfyQuery indexInTableDimRangeFieldSpec
			className = String("au.edu.anu.twcore.archetype.tw.IndexDimensionQuery")
	hasEdge trackTableEdgeSpec
		isOfClass = String("trackTable")
		toNode = String("table")
		multiplicity = IntegerRange("0..*")
		mustSatisfyQuery validTrackTableCategory
			className = String("au.edu.anu.twcore.archetype.tw.FindCommonCategoryQuery")
		mustSatisfyQuery leafTableSpec
			className = String("au.edu.anu.twcore.archetype.tw.EndNodeHasPropertyQuery")
			propname = String("dataElementType")
		hasProperty trackTableIndexSpec
			hasName = String("index")
			type = String("TrackerType")
			multiplicity = IntegerRange("1..1")
		mustSatisfyQuery indexInTableDimRangeTableSpec
			className = String("au.edu.anu.twcore.archetype.tw.IndexDimensionQuery")
	hasProperty groupBySpec
		hasName = String("groupBy")
		type = String("Grouping")
		multiplicity = IntegerRange("0..1")
	hasProperty viewOthersSpec
		hasName = String(viewOthers)
		type = String("Boolean")
		multiplicity = IntegerRange("0..1")

hasNode lifeCycleSpec
	isOfClass = String("lifeCycle")
	hasParent = StringTable(([1]"dynamics:"))
	multiplicity = IntegerRange("0..*")
	hasProperty lifeCycleParameterSpec
		hasName = String("parameterClass")
		type =  String("String") 
		multiplicity = IntegerRange("0..1") 
	hasEdge lifeCycleToCategorySetSpec
		isOfClass = String("appliesTo")
		toNode = String("categorySet")
		multiplicity = IntegerRange("1..1")
	mustSatisfyQuery lifeCycleHasRecruitOrProduceChildQuery
		className = String("au.edu.anu.twcore.archetype.tw.NodeAtLeastOneChildLabelOfQuery")
		labels = StringTable(([2]"recruit","produce"))
	// TODO: check this category is not used by Systems, ie lifeCycle categories and system
	// categories should be completely separate
	hasEdge lifeCycleCategoryBelongsToSpec
		isOfClass = String("belongsTo")
		toNode = String("category:")
		multiplicity = IntegerRange("0..*")

hasNode recruitSpec
	isOfClass = String("recruit")
	hasParent = StringTable(([1]"lifeCycle:"))
	multiplicity = IntegerRange("0..*")
	hasEdge recruitProcessSpec
		isOfClass = String("effectedBy")
		toNode = String("process")
		multiplicity = IntegerRange("1..1")
	hasEdge recruitToCategorySpec
		isOfClass = String("toCategory")
		toNode = String("category")
		multiplicity = IntegerRange("1..1")
	hasEdge recruitFromCategorySpec
		isOfClass = String("fromCategory")
		toNode = String("category")
		multiplicity = IntegerRange("1..1")
	mustSatisfyQuery recruitCategoryInLifeCycleSet
		className = String("au.edu.anu.twcore.archetype.tw.IsInLifeCycleCategorySetQuery")
	mustSatisfyQuery validRecruitProcess
		className = String("au.edu.anu.twcore.archetype.tw.ValidLifeCycleProcessQuery")
		
hasNode produceSpec
	isOfClass = String("produce")
	hasParent = StringTable(([1]"lifeCycle:"))
	multiplicity = IntegerRange("0..*")
	hasEdge productionProcessSpec
		isOfClass = String("effectedBy")
		toNode = String("process")
		multiplicity = IntegerRange("1..1")
	hasEdge produceToCategorySpec
		isOfClass = String("toCategory")
		toNode = String("category")
		multiplicity = IntegerRange("1..1")
	hasEdge produceFromCategorySpec
		isOfClass = String("fromCategory")
		toNode = String("category")
		multiplicity = IntegerRange("1..1")
	mustSatisfyQuery produceCategoryInLifeCycleSet
		className = String("au.edu.anu.twcore.archetype.tw.IsInLifeCycleCategorySetQuery")
	mustSatisfyQuery validProduceProcess
		className = String("au.edu.anu.twcore.archetype.tw.ValidLifeCycleProcessQuery")

hasNode stoppingConditionSpec
	isOfClass = String("stoppingCondition")
	hasParent = StringTable(([1]"dynamics:"))
	// I think we should enforce at least one rather than have a default one if omitted
	// No - the default is: run forever. Means no stopping condition
	multiplicity = IntegerRange("0..*")
	hasProperty stoppingConditionSubclassPropertySpec
		hasName = String("subclass")
		type = String("String")
		multiplicity = IntegerRange("1..1")
		mustSatisfyQuery validStoppingConditionSubClassSpec
			className = String("au.edu.anu.twcore.archetype.tw.IsInValueSetQuery")
			values = StringTable(([6]+
			"au.edu.anu.twcore.ecosystem.runtime.stop.SimpleStoppingCondition",+
			"au.edu.anu.twcore.ecosystem.runtime.stop.ValueStoppingCondition",+
			"au.edu.anu.twcore.ecosystem.runtime.stop.InRangeStoppingCondition",+
			"au.edu.anu.twcore.ecosystem.runtime.stop.OutRangeStoppingCondition",+
			"au.edu.anu.twcore.ecosystem.runtime.stop.MultipleOrStoppingCondition",+
			"au.edu.anu.twcore.ecosystem.runtime.stop.MultipleAndStoppingCondition"))
	mustSatisfyQuery CheckSubArchetypeQuerySimpleStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.SimpleStoppingCondition","3wSA-SimpleStoppingCondition.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryValueStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.ValueStoppingCondition","3wSA-ValueStoppingCondition.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryInRangeStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.InRangeStoppingCondition","3wSA-RangeStoppingCondition.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryOutRangeStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.OutRangeStoppingCondition","3wSA-RangeStoppingCondition.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryMultipleOrStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.MultipleOrStoppingCondition","3wSA-MultipleStoppingCondition.ugt"))
	mustSatisfyQuery CheckSubArchetypeQueryMultipleAndStop
		className = String("au.edu.anu.twcore.archetype.tw.CheckSubArchetypeQuery")
		parameters = StringTable(([3]"subclass","au.edu.anu.twcore.ecosystem.runtime.stop.MultipleAndStoppingCondition","3wSA-MultipleStoppingCondition.ugt"))
			
// how to specify initial community:

hasNode initialStateSpec
	isOfClass = String("initialState")
	hasParent = StringTable(([1]"dynamics:"))
	multiplicity = IntegerRange("0..1")
	hasEdge ecosystemToSourceLoadFromSpec
		isOfClass = String("loadFrom")
		toNode = String("dataSource")
		multiplicity = IntegerRange("0..*")
	
// set of values for a parameter set linked to a group of components or a life cycle	
// NB: a group represents either a lifeCycle or just a group of components with the same parameters
// when a group is a life cycle, then it MUST have a subgroup matching each of its
// lifecycle categories
// TODO: implement this constraint as a query
hasNode groupSpec
	isOfClass = String("group")
	hasParent = StringTable(([2]"initialState:","group:"))
	multiplicity = IntegerRange("0..*")
	hasEdge groupToSystemSpec
		isOfClass = String("groupOf")
		toNode = String("component")
		multiplicity = IntegerRange("0..1")
	hasEdge groupToLifeCycleSpec
		isOfClass = String("cycle")
		toNode = String("lifeCycle")
		multiplicity = IntegerRange("0..1")
	hasEdge groupToSourceLoadFromSpec
		isOfClass = String("loadFrom")
		toNode = String("dataSource")
		multiplicity = IntegerRange("0..*")
	mustSatisfyQuery groupObjectSpec
		className = String("au.edu.anu.twcore.archetype.tw.OutNodeXorQuery")
		nodeLabel1 = String("component")
		nodeLabel2 = String("lifeCycle")
	
// initial state for an individual component 	
hasNode individualSpec
	isOfClass = String("individual")
	hasParent = StringTable(([2]"initialState:","group:"))
	multiplicity = IntegerRange("0..*")
	hasEdge individualToSystemSpec
		isOfClass = String("instanceOf")
		toNode = String("component")
		multiplicity = IntegerRange("1..1")
	hasEdge individualToSourceLoadFromSpec
		isOfClass = String("loadFrom")
		toNode = String("dataSource")
		multiplicity = IntegerRange("0..*")

// parameter values for a group as specified in groupSpec above
hasNode parameterValuesSpec
	isOfClass = String("parameterValues")
	hasParent = StringTable(([3]"initialState:","group:","individual:"))
	multiplicity = IntegerRange("0..1")
	// then provide property (name,value) pairs - of course names must match category definitions
	// caution: if parameter values are associated to an individual, it means it is unique in its
	// category, its parameters are specific to it and no other individual with the same values
	// will ever exist. Shared parameter values must be set at the group level
	
hasNode variableValuesSpec
	isOfClass = String("variableValues")
	hasParent = StringTable(([1]"individual:"))
	multiplicity = IntegerRange("0..1")
	// then provide property (name,value) pairs - of course names must match category definitions
	
	