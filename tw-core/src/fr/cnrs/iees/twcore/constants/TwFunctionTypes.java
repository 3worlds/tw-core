/*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*                    *** 3Worlds - A software for the simulation of ecosystems ***
*                    *                                                           *
*                    *        by:  Jacques Gignoux - jacques.gignoux@upmc.fr     *
*                    *             Ian D. Davies   - ian.davies@anu.edu.au       *
*                    *             Shayne R. Flint - shayne.flint@anu.edu.au     *
*                    *                                                           *
*                    *         http:// ???                                       *
*                    *                                                           *
*                    *************************************************************
* CAUTION: generated code - do not modify
* generated by CentralResourceGenerator on Wed Apr 08 10:29:42 CEST 2020
*/
package fr.cnrs.iees.twcore.constants;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import fr.cnrs.iees.io.parsing.ValidPropertyTypes;

import java.util.EnumSet;
import fr.cnrs.iees.twcore.generators.process.ArgumentGroups;
import static fr.cnrs.iees.twcore.generators.process.ArgumentGroups.*;

public enum TwFunctionTypes {

// ChangeState: change the state, ie the values of internal variables, of a system component
	ChangeState ("changeState", "void"),

// ChangeCategoryDecision: change category of a system component according to life cycle (has no effect if no life cycle is specified)
	ChangeCategoryDecision ("changeCategory", "String"),

// CreateOtherDecision: create another system component, of the same categories if no life cycle is present, otherwise as specified by the life cycle
	CreateOtherDecision ("nNew", "double"),

// DeleteDecision: delete self
	DeleteDecision ("delete", "boolean"),

// ChangeOtherState: _focal_ changes the state of _other_
	ChangeOtherState ("changeOtherState", "void"),

// ChangeOtherCategoryDecision: _focal_ changes the category of _other_ (requires a life cycle for other)
	ChangeOtherCategoryDecision ("changeCategory", "String"),

// DeleteOtherDecision: _focal_ deletes _other_
	DeleteOtherDecision ("delete", "boolean"),

// RelateToDecision: _focal_ establishes a new relation to _other_
	RelateToDecision ("relateTo", "boolean"),

// MaintainRelationDecision: decision to maintain or remove an existing relation
	MaintainRelationDecision ("maintainRelation", "boolean"),

// ChangeRelationState: change the state of a relation, i.e. possibly both the state of focal and other at the same time
	ChangeRelationState ("changeRelationState", "void"),

// SetInitialState: sets the initial state of a newly created SystemComponent
	SetInitialState ("setInitialState", "void"),

// SetOtherInitialState: sets the initial state of a newly created SystemComponent given a parent component
	SetOtherInitialState ("setOtherInitialState", "void");

	private final String method;
	private final String returnType;

	private TwFunctionTypes(String method, String returnType) {
		this.method = method;
		this.returnType = returnType;
	}

	public String method() {
		return method;
	}

	public String returnType() {
		return returnType;
	}

	public static String[] toStrings() {
		String[] result = new String[TwFunctionTypes.values().length];
		for (TwFunctionTypes s: TwFunctionTypes.values())
			result[s.ordinal()] = s.name();
		Arrays.sort(result);
		return result;
	}

	public static Set<String> keySet() {
		Set<String> result = new HashSet<String>();
		for (TwFunctionTypes e: TwFunctionTypes.values())
			result.add(e.toString());
		return result;
	}

	public static TwFunctionTypes defaultValue() {
		return ChangeState;
	}

	static {
		ValidPropertyTypes.recordPropertyType(TwFunctionTypes.class.getSimpleName(),
		TwFunctionTypes.class.getName(),defaultValue());
	}

    public Set<ArgumentGroups> readOnlyArguments() {
        switch (this) {
            case ChangeOtherCategoryDecision:
            case ChangeOtherState:
            case ChangeRelationState:
            case DeleteOtherDecision:
            case MaintainRelationDecision:
            case RelateToDecision:
                return EnumSet.allOf(ArgumentGroups.class);
            case ChangeCategoryDecision:
            case ChangeState:
            case CreateOtherDecision:
            case DeleteDecision:
                return EnumSet.of(t,dt,limits,
                    ecosystemPar,ecosystemPop,lifeCyclePar,lifeCyclePop,groupPar,groupPop,
                    focalAuto,focalLtc,focalDrv,focalDec,focalLoc);
            case SetInitialState:
                return EnumSet.of(t,dt,limits,
                    ecosystemPar,ecosystemPop,lifeCyclePar,lifeCyclePop,groupPar,groupPop);
            case SetOtherInitialState:
                return EnumSet.of(t,dt,limits,
                    ecosystemPar,ecosystemPop,lifeCyclePar,lifeCyclePop,
                    groupPar,groupPop,otherGroupPar,otherGroupPop,
                    focalAuto,focalLtc,focalDrv,focalDec,focalLoc);
            default:
                return EnumSet.noneOf(ArgumentGroups.class);
        }
    }

    public Set<ArgumentGroups> writeableArguments() {
	    switch (this) {
	        case ChangeCategoryDecision:
	        case CreateOtherDecision:
	        case DeleteDecision:
	        case ChangeOtherCategoryDecision:
	        case DeleteOtherDecision:
	        case MaintainRelationDecision:
	        case RelateToDecision:
	            return EnumSet.noneOf(ArgumentGroups.class);
	        case ChangeOtherState:
	            return EnumSet.of(nextOtherDrv,otherDec,nextOtherLoc);
	        case ChangeRelationState:
	            return EnumSet.of(nextFocalDrv,focalDec,nextFocalLoc,
	                nextOtherDrv,otherDec,nextOtherLoc); // also add relation state in a far future
	        case ChangeState:
	            return EnumSet.of(nextFocalDrv,focalDec,nextFocalLoc);
	        case SetInitialState:
	            return EnumSet.of(focalLtc,focalDrv,focalLoc);
	        case SetOtherInitialState:
	            return EnumSet.of(otherLtc,otherDrv,otherLoc);
	        default:
	            return EnumSet.noneOf(ArgumentGroups.class);
        }
    }

}

